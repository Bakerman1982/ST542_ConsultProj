---
title: "Analysis"
author: "Hanan Ali"
date: "2025-06-25"
output: html_document
---

Employer dataset prep
```{r setup, include=FALSE}
######################################
##           Load Library           ##
######################################

#Complimentary "Install Packages" code
#install.packages("tidyverse")
#install.packages("janitor")
#install.packages("gtools")
#install.packages("naniar")

#Load Libraries
library(tidyverse)
library(janitor)
library(gtools)
library(naniar)


#############################################
## Connect, Import, group and primary key. ##
#############################################

#Read data into R environment. 
Employer_Data <- read_csv("Employer_Dentistry_Survey.csv") %>% clean_names()
#Name new object to work with leaving original intact/untouched
Employer_Data_Clean <- Employer_Data

#Add grouping identifier now so if we combine data later, we have our groups delineated. 
Employer_Data_Clean <- Employer_Data_Clean %>%
  mutate(
    group = "Employer", #Categorizes all responses as Employer
    respondent_id = row_number() #Maintains respondent ID
  )


############################
#####  DATA WRANGLING  #####
############################

#Adjust headers for readability and add grouping identifier.
#1.) Remove redundancy in column names, 
#2.) Replace "quid" with "Q", and
#3.) All "_text" with "T".
colnames(Employer_Data_Clean) <- gsub("_text$", "_T", gsub("q", "Q", colnames(Employer_Data_Clean)))
#4.) Format the column headers so that it is sort-able both by question and sub question. So where 
#questions are formatted with header Q10_2, the header will now be Q10_02.  This preserves ordering
#and makes indexing easier. 
pad_question_ids <- function(col_names) {
  col_names %>%
    str_replace_all("Q(\\d{1})(?!\\d)", "Q0\\1") %>%
    str_replace_all("Q(\\d{2})_(\\d{1})(?!\\d)", "Q\\1_0\\2")}

#Apply above formatting changes to data frame column names
colnames(Employer_Data_Clean) <- pad_question_ids(colnames(Employer_Data_Clean))

#Removes Qualtric metadata from the first two rows
Employer_Data_Clean <- Employer_Data_Clean %>% slice(-1, -2)



### QUESTION-BY-QUESTION Cleaning

#------------
#Question #04
#------------
#Renames the text response to index 13 and places it in its order. 
Employer_Data_Clean <- Employer_Data_Clean %>%
  rename(Q04_13 = Q04_12_T)

#------------
#Question #09 does not need correcting. 
#------------

#------------
#Question #16
#------------
#Renames the text response to index 11 and places it in its order. 
Employer_Data_Clean <- Employer_Data_Clean %>%
  rename(Q16_11 = Q16_10_T) 

#Process Q12: Split responses and pivot to wide format
Employer_Data_Clean <- Employer_Data_Clean %>%
  mutate(respondent_id = row_number()) %>%
  separate_rows(Q16, sep = ",") %>%
  mutate(Q16 = str_trim(Q16)) %>%
  #filter(!is.na(Q16)) %>%  # üîß prevent Q16_NA column in pivot_wider
  mutate(Q16 = str_pad(Q16, width = 2, pad = "0"),
         value = 1) %>%
  pivot_wider(
    names_from = Q16,
    names_prefix = "Q16_",
    values_from = value,
    values_fill = 0
  ) %>%
  right_join(select(Employer_Data_Clean, respondent_id), by = "respondent_id")  # üîÅ bring back NA responders


if (!"Q16_09" %in% colnames(Employer_Data_Clean)) {
  Employer_Data_Clean$Q16_09 <- 0
}


#------------
#Question #17
#------------
#Renames the text response to index 14 and places it in its order.
Employer_Data_Clean <- Employer_Data_Clean %>%
  rename(Q17_15 = Q17_14_T)

#------------
#Question #20
#------------
# Create binary indicator columns from Q16.  Recall that Q16 was a multiple responsive
# "Select all that Apply" question where participants could choose however many they 
# wanted.  In the Qualtrics output, these responses were comma-separated.  This query
# breaks each reponse out over a column and assigns values of "0" or "1" depending on 
# whether they choose that particular response. The same issue is address in Question #20. 
Q20_binary <- Employer_Data_Clean %>%
  select(respondent_id, Q20) %>%
  separate_rows(Q20, sep = ",") %>%
  mutate(Q20 = str_trim(Q20)) %>%
  #filter(!is.na(Q20)) %>%   # üëà Prevents Q20_NA from being created
  mutate(Q20 = str_pad(Q20, width = 2, pad = "0"),
         value = 1) %>%
  pivot_wider(
    names_from = Q20,
    names_prefix = "Q20_",
    values_from = value,
    values_fill = 0
  ) %>%
  right_join(select(Employer_Data_Clean, respondent_id), by = "respondent_id")

# Remove the old Q16 columns and join the binary ones on respondent_id
Employer_Data_Clean <- Employer_Data_Clean %>%
  select(-Q20) %>%
  left_join(Q20_binary, by = "respondent_id")

# Renames the text response to index 07 and places it in its order.
Employer_Data_Clean <- Employer_Data_Clean %>%
  rename(Q20_07 = Q20_06_T) %>%
  relocate(Q20_07, .after = Q20_06)

# Add Q16_05 as a column of zeros if it doesn't exist (it does not)
if (!"Q20_05" %in% colnames(Employer_Data_Clean)) {
  Employer_Data_Clean$Q20_05 <- 0
}

#------------
#Question #21
#------------
#Renames the text response to index 07 and places it in its order.
Employer_Data_Clean <- Employer_Data_Clean %>%
  rename(Q21_07 = Q21_06_T) 

#------------
#Question #22 does not need correcting. 
#------------

#------------
#Question #24 does not need correcting. 
#------------

#------------
#Question #25
#------------
# Create binary indicator columns from Q25.  Recall that Q25 was a multiple responsive
# "Select all that Apply" question where participants could choose however many they 
# wanted.  In the Qualtrics output, these responses were comma-separated.  This query
# breaks each reponse out over a column and assigns values of "0" or "1" depending on 
# whether they choose that particular response. The same issue is address in Question #16. 
Q25_binary <- Employer_Data_Clean %>%
  select(respondent_id, Q25) %>%
  separate_rows(Q25, sep = ",") %>%
  mutate(Q25 = str_trim(Q25)) %>%
  #filter(!is.na(Q25)) %>%   # üëà Prevents Q25_NA
  mutate(Q25 = str_pad(Q25, width = 2, pad = "0"),
         value = 1) %>%
  pivot_wider(
    names_from = Q25,
    names_prefix = "Q25_",
    values_from = value,
    values_fill = 0
  ) %>%
  right_join(select(Employer_Data_Clean, respondent_id), by = "respondent_id")


# Remove the old Q16 columns and join the binary ones in
Employer_Data_Clean <- Employer_Data_Clean %>%
  select(-Q25) %>%
  left_join(Q25_binary, by = "respondent_id")

# Add Q25_13 as a column of zeros if it doesn't exist (it does not)
if (!"Q25_13" %in% colnames(Employer_Data_Clean)) {
  Employer_Data_Clean$Q25_13 <- 0
}

# Rename and relocate the "Other" text entry for Q16
Employer_Data_Clean <- Employer_Data_Clean %>%
  rename(Q25_14 = Q25_13_T) %>%
  relocate(Q25_14, .after = Q25_13)

#------------
#Question #26
#------------
#Renames the text response to index 14 and places it in its order. 
Employer_Data_Clean <- Employer_Data_Clean %>%
  rename(Q26_14 = Q26_13_T) 


##########################
##### FILTER DATASET #####
##########################
#"Q20_NA"
#"Q25_NA"


#Remove irrelevant/problematic columns to the research/stats questions
Employer_Data_Clean <- Employer_Data_Clean %>%
  mutate(progress = as.numeric(progress)) %>%
  filter(Q02 == '1', progress >= 50) %>%
  select(
    ip_address, progress, duration_in_seconds,
    finished, recorded_date, response_id, group, respondent_id,
    starts_with("Q04"),
    starts_with("Q09"),
    starts_with("Q16"),
    starts_with("Q17"),
    starts_with("Q20"),
    starts_with("Q21"),
    starts_with("Q22"),
    starts_with("Q24"),
    starts_with("Q25"),
    starts_with("Q26"),
    -Q16_NA,  # üëà drop this
    -Q20_NA,  # üëà drop this
    -Q25_NA
  )

#Identify metadata columns to keep at the front
meta_cols <- c("ip_address", "progress", "duration_in_seconds",
               "finished", "recorded_date", "response_id", "group", "respondent_id")

#Identify and sort Q columns using mixedsort
q_cols <- setdiff(colnames(Employer_Data_Clean), meta_cols)
q_cols_sorted <- mixedsort(q_cols)

#Reorder the data frame
Employer_Data_Clean <- Employer_Data_Clean[, c(meta_cols, q_cols_sorted)]

#Print the entire dataframe
Employer_Data_Clean %>% print(n = 43)
colnames(Employer_Data_Clean)


count(Employer_Data_Clean)
```



Educator Survey Dataset Prep
```{r}
######################################
##           Load Library           ##
######################################

#Complimentary "Install Packages" code
#install.packages("tidyverse")
#install.packages("janitor")
#install.packages("gtools")
#install.packages("naniar")

#Load Libraries
library(tidyverse)
library(janitor)
library(gtools)
library(naniar)


#############################################
## Connect, Import, group and primary key. ##
#############################################

#Read data into R environment. 
Educator_Data <- read_csv("PCVE_Dentistry_Survey.csv") %>% clean_names()
#Name new object to work with leaving original intact/untouched
Educator_Data_Clean <- Educator_Data

#Add identifier affirming educator responses. 
Educator_Data_Clean <- Educator_Data_Clean %>%
  mutate(
    group = "Educator",
    respondent_id = row_number()
  )

############################
#####  DATA WRANGLING  #####
############################

#Adjust headers for readability and add grouping identifier.
  #1.) Remove redundancy in column names, 
  #2.) Replace "quid" with "Q", and
  #3.) All "_text" with "T".
colnames(Educator_Data_Clean) <- gsub("_text$", "_T", gsub("q", "Q", colnames(Educator_Data_Clean)))
  #4.) Format the column headers so that it is sort-able both by question and sub question. So where 
    #questions are formatted with header Q10_2, the header will now be Q10_02.  This preserves ordering
    #and makes indexing easier. 
pad_question_ids <- function(col_names) {
  col_names %>%
    str_replace_all("Q(\\d{1})(?!\\d)", "Q0\\1") %>%
    str_replace_all("Q(\\d{2})_(\\d{1})(?!\\d)", "Q\\1_0\\2")}

#Apply above formatting changes to data frame column names
colnames(Educator_Data_Clean) <- pad_question_ids(colnames(Educator_Data_Clean))

#Removes Qualtric metadata from the first two rows
Educator_Data_Clean <- Educator_Data_Clean %>% slice(-1, -2)


### QUESTION-BY-QUESTION Cleaning

#------------
#Question #04
#------------
#Renames the text response to index 13 and places it in its order. 
Educator_Data_Clean <- Educator_Data_Clean %>%
  rename(Q04_13 = Q04_12_T)

#------------
#Question #07 does not need correcting. 
#------------

#------------
#Question #12
#------------
  #Renames the text response to index 11 and places it in its order. 
Educator_Data_Clean <- Educator_Data_Clean %>%
  rename(Q12_11 = Q12_10_T) 

  #Process Q12: Split responses and pivot to wide format
Educator_Data_Clean <- Educator_Data_Clean %>%
  # Create a temporary respondent ID if not already done
  mutate(respondent_id = row_number()) %>%
  # Separate comma-separated values into long format
  separate_rows(Q12, sep = ",") %>%
  # Trim whitespace if any
  mutate(Q12 = str_trim(Q12)) %>%
  # Pad values with leading zero for consistent column naming (01, 02, ..., 11)
  mutate(Q12 = str_pad(Q12, width = 2, pad = "0"),
         value = 1) %>%
  # Pivot wider to get binary indicator columns
  pivot_wider(
    names_from = Q12,
    names_prefix = "Q12_",
    values_from = value,
    values_fill = 0
  )

#------------
#Question #13
#------------
#Renames the text response to index 14 and places it in its order.
Educator_Data_Clean <- Educator_Data_Clean %>%
  rename(Q13_14 = Q13_13_T)

#------------
#Question #16
#------------
# Create binary indicator columns from Q16.  Recall that Q16 was a multiple responsive
# "Select all that Apply" question where participants could choose however many they 
# wanted.  In the Qualtrics output, these responses were comma-separated.  This query
# breaks each reponse out over a column and assigns values of "0" or "1" depending on 
# whether they choose that particular response. The same issue is address in Question #20. 
Q16_binary <- Educator_Data_Clean %>%
  select(respondent_id, Q16) %>%
  separate_rows(Q16, sep = ",") %>%
  mutate(Q16 = str_trim(Q16)) %>%
  mutate(Q16 = str_pad(Q16, width = 2, pad = "0"),
         value = 1) %>%
  pivot_wider(
    names_from = Q16,
    names_prefix = "Q16_",
    values_from = value,
    values_fill = 0
  )

  # Remove the old Q16 columns and join the binary ones on respondent_id
Educator_Data_Clean <- Educator_Data_Clean %>%
  select(-Q16) %>%
  left_join(Q16_binary, by = "respondent_id")

  # Renames the text response to index 07 and places it in its order.
Educator_Data_Clean <- Educator_Data_Clean %>%
  rename(Q16_07 = Q16_06_T) %>%
  relocate(Q16_07, .after = Q16_06)

  # Add Q16_05 as a column of zeros if it doesn't exist (it does not)
if (!"Q16_05" %in% colnames(Educator_Data_Clean)) {
  Educator_Data_Clean$Q16_05 <- 0
}

#------------
#Question #17
#------------
#Renames the text response to index 07 and places it in its order.
Educator_Data_Clean <- Educator_Data_Clean %>%
  rename(Q17_07 = Q17_06_T) 

#------------
#Question #18 does not need correcting. 
#------------

#------------
#Question #19 does not need correcting. 
#------------

#------------
#Question #20
#------------
# Create binary indicator columns from Q16.  Recall that Q16 was a multiple responsive
# "Select all that Apply" question where participants could choose however many they 
# wanted.  In the Qualtrics output, these responses were comma-separated.  This query
# breaks each reponse out over a column and assigns values of "0" or "1" depending on 
# whether they choose that particular response. The same issue is address in Question #16. 
Q20_binary <- Educator_Data_Clean %>%
  select(respondent_id, Q20) %>%
  separate_rows(Q20, sep = ",") %>%
  mutate(Q20 = str_trim(Q20)) %>%
  mutate(Q20 = str_pad(Q20, width = 2, pad = "0"),
         value = 1) %>%
  pivot_wider(
    names_from = Q20,
    names_prefix = "Q20_",
    values_from = value,
    values_fill = 0
  )

# Remove the old Q16 columns and join the binary ones in
Educator_Data_Clean <- Educator_Data_Clean %>%
  select(-Q20) %>%
  left_join(Q20_binary, by = "respondent_id")

# Rename and relocate the "Other" text entry for Q16
Educator_Data_Clean <- Educator_Data_Clean %>%
  rename(Q20_14 = Q20_13_T) %>%
  relocate(Q20_14, .after = Q20_13)

#------------
#Question #21
#------------
#Renames the text response to index 14 and places it in its order. 
Educator_Data_Clean <- Educator_Data_Clean %>%
  rename(Q21_14 = Q21_13_T) 


##########################
##### FILTER DATASET #####
##########################

#Remove irrelevant/problematic columns to the research/stats questions
Educator_Data_Clean <- Educator_Data_Clean %>%
  mutate(progress = as.numeric(progress)) %>%
  filter(Q44 != "2", progress >= 50) %>%
  select(
    ip_address, progress, duration_in_seconds,
    finished, recorded_date, response_id, group, respondent_id,
    starts_with("Q04"),
    starts_with("Q07"),
    starts_with("Q12"),
    starts_with("Q13"),
    starts_with("Q16"),
    starts_with("Q17"),
    starts_with("Q18"),
    starts_with("Q19"),
    starts_with("Q20"),
    starts_with("Q21")
  )



#Identify metadata columns to keep at the front
meta_cols <- c("ip_address", "progress", "duration_in_seconds",
               "finished", "recorded_date", "response_id", "group", "respondent_id")

#Identify and sort Q columns using mixedsort
q_cols <- setdiff(colnames(Educator_Data_Clean), meta_cols)
q_cols_sorted <- mixedsort(q_cols)

#Reorder the data frame
Educator_Data_Clean <- Educator_Data_Clean[, c(meta_cols, q_cols_sorted)]
Educator_Data_Clean
colnames(Educator_Data_Clean)

#Print the entire dataframe
Educator_Data_Clean %>% print(n = 43)

count(Educator_Data_Clean)
```




Are there significant differences between educators and practice owners in their belief that new graduates are competent in key dental skills on their first day of practice?

First I'll combine the datasets and keep it to question 4 only
```{r}
library(dplyr)
   
# Add group identifiers
educator_cleaned <- Educator_Data_Clean %>%
  mutate(group = "Educator")

employer_cleaned <- Employer_Data_Clean %>%
  mutate(group = "Employer")

# Define Q4 variable names for both datasets
q4_vars <- paste0("Q04_", sprintf("%02d", 1:12))  # creates Q04_01 to Q04_12

# Subset and label the educator data
educator_q4 <- educator_cleaned %>%
  select(all_of(q4_vars)) %>%
  mutate(group = "Educator")

# Subset and label the employer data
employer_q4 <- employer_cleaned %>%
  select(all_of(q4_vars)) %>%
  mutate(group = "Employer")

# Combine datasets
combined_data <- bind_rows(educator_q4, employer_q4)

```



Run Mann-Whitney U Test
```{r}
library(tidyr)
library(dplyr)
library(purrr)

# Pivot data to long format
q4_long <- combined_data %>%
  pivot_longer(
    cols = starts_with("Q04_"),
    names_to = "Skill",
    values_to = "Rating_num"
  ) %>%
  filter(!is.na(Rating_num))

#Must coerce character to numeric explicitly because removing na values is not enough so redo and see if it works
q4_long <- q4_long %>%
  mutate(Rating_num = as.numeric(Rating_num))

str(q4_long)

# Run Mann-Whitney U test for each skill
mw_results <- q4_long %>%
  filter(!is.na(Rating_num)) %>%  # Exclude rows with NA ratings because there is NA values hindering it from being able to run 
  group_by(Skill) %>%
  summarise(
    p_value = wilcox.test(Rating_num ~ group)$p.value,
    median_educator = median(Rating_num[group == "Educator"]),
    median_employer = median(Rating_num[group == "Employer"]),
    n_educator = sum(group == "Educator"),
    n_employer = sum(group == "Employer"),
    .groups = "drop"
  ) %>%
  arrange(p_value)

print(mw_results)


```
We used the Mann-Whitney U test, a non-parametric method appropriate for comparing ordinal ratings between two independent groups. Ratings ranged from 1 (Strongly Disagree) to 4 (Strongly Agree) regarding new graduate competence for each skill.

Results:

For most dental skills, the differences in ratings between educators and practice owners were not statistically significant (p-values well above 0.05), indicating that both groups generally agree on the competency level of new graduates. The skill ‚Äúinterpreting dental radiographs‚Äù (dental X-rays) showed the closest difference with a p-value of 0.064. Although this is just above the conventional 0.05 threshold, it suggests a trend where practice owners were slightly more confident in new graduates‚Äô abilities compared to educators. Median ratings for this skill were equal (3 out of 4), reinforcing that the difference is subtle.

Interpretation: There is no strong evidence that educators and practice owners disagree on the preparedness of new graduates for dental tasks. Both groups mostly agree on which skills new graduates can perform competently from day one. The only exception might be interpreting dental X-rays, where practice owners seem a little more optimistic about new grads' skills ‚Äî but this difference isn‚Äôt strong enough to be sure it‚Äôs real. The near-significant difference in confidence regarding interpreting dental X-rays may warrant further investigation but should be interpreted cautiously.


 






Is there a difference between educators and practice owners in their reports (educators‚Äô actual teaching vs. owners‚Äô perceptions) of which dental skills were taught in the pre-clinical DVM curriculum for recent graduates?

Employer Q16: ‚ÄúWhat format of instruction in dentistry does your DVM program provide during the clinical year?‚Äù (select all that apply)

Educator Q12: ‚ÄúWhich of the following skills are taught as part of the pre-clinical dentistry courses in your DVM program?‚Äù (select all that apply)
```{r}
library(dplyr)
library(tidyr)

# Select Q12 columns from Educator data and label group
educator_q12 <- Educator_Data_Clean %>%
  select(starts_with("Q12_")) %>%
  mutate(group = "Educator")

# Select Q16 columns from Employer data and label group
employer_q16 <- Employer_Data_Clean %>%
  select(starts_with("Q16_")) %>%
  mutate(group = "Employer")

# Make sure both have the same number of columns for binding
# You might want to subset Q16 columns to match Q12 (e.g. Q16_01 to Q16_11, or subset to Q16_01:Q16_07)
employer_q16 <- employer_q16 %>%
  select(Q16_01:Q16_07) %>%
  mutate(group = "Employer")

# Now rename employer_q16 columns to match educator_q12 columns for easier comparison
colnames(employer_q16)[1:7] <- colnames(educator_q12)[1:7]

# Combine the datasets (you might need to drop extra columns or handle mismatches)
combined_q12_q16 <- bind_rows(educator_q12, employer_q16)


# Assuming your combined dataset is wide format like:
# Columns: Q12_01, Q12_02, ... Q12_07, group

combined_long <- combined_q12_q16 %>%
  pivot_longer(
    cols = starts_with("Q12_"),  # or Q16_ columns renamed as Q12_01 etc.
    names_to = "Skill_Format",
    values_to = "Taught"
  ) %>%
  mutate(
    Taught = as.numeric(as.character(Taught)) 
  )

#Convert Q12_11 to numeric since it is a character which is causing the pivot_longer error.
combined_q12_q16 <- combined_q12_q16 %>%
  mutate(Q12_11 = as.numeric(Q12_11))


combined_long <- combined_q12_q16 %>%
  pivot_longer(
    cols = starts_with("Q12_"),
    names_to = "Skill_Format",
    values_to = "Taught"
  )


# Make sure your data is in long format
combined_long <- combined_q12_q16 %>%
  pivot_longer(
    cols = starts_with("Q12_"),   
    names_to = "Skill_Format",
    values_to = "Taught"
  ) %>%
  mutate(Taught = as.numeric(Taught))  


table(combined_long$group[combined_long$Skill_Format == "Q12_11"], 
      combined_long$Taught[combined_long$Skill_Format == "Q12_11"])

#check what data values are in here causing the issues
combined_long %>%
  filter(Skill_Format == "Q12_11") %>%
  select(group, Taught)


```

During the analysis of the combined dataset comparing educators‚Äô reports and practice owners‚Äô perceptions of which dental skills are taught in the pre-clinical DVM curriculum, we encountered a data quality issue with the survey item labeled Q12_11. Specifically, all responses for this skill were recorded as missing values (NAs) across both groups‚Äîeducators and employers. Because there were no actual observed responses for this item, the contingency table used for statistical testing contained no valid data points. Removing Q12_11 allows us to focus on skills where sufficient data exist to reliably assess differences in perceptions about curriculum content between educators and practice owners.




```{r}
library(dplyr)

test_results <- combined_long_filtered %>%
  group_by(Skill_Format) %>%
  summarise(
    tab = list(table(group, Taught)),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    is_valid = length(dim(tab)) == 2 &&
               all(dim(tab) == c(2, 2))
  ) %>%
  filter(is_valid) %>%
  mutate(
    p_value = fisher.test(tab)$p.value,
    n_educator = sum(tab["Educator", ]),
    n_employer = sum(tab["Employer", ]),
    prop_educator = tab["Educator", "1"] / sum(tab["Educator", ]),
    prop_employer = tab["Employer", "1"] / sum(tab["Employer", ])
  ) %>%
  ungroup() %>%
  select(-tab, -is_valid) %>%
  arrange(p_value)


print(test_results)

```


CONTINUE FROM HERE: need to figure out why question 16 data is not in combined set and rerun this test





```{r}
# Step 1: Select and rename employer Q16 columns to match Q12 labels
employer_q16 <- Employer_Data_Clean %>%
  select(Q16_01:Q16_07) %>%
  rename_with(~ paste0("Q12_", sprintf("%02d", 1:7)), .cols = everything()) %>%
  mutate(group = "Employer")

# Step 2: Select educator Q12 columns
educator_q12 <- Educator_Data_Clean %>%
  select(Q12_01:Q12_07) %>%
  mutate(group = "Educator")

# Step 3: Combine the two
combined_q12_q16 <- bind_rows(educator_q12, employer_q16)



combined_long <- combined_q12_q16 %>%
  pivot_longer(
    cols = starts_with("Q12_"),
    names_to = "Skill_Format",
    values_to = "Taught"
  ) %>%
  mutate(Taught = as.numeric(as.character(Taught)))




# Remove skills with invalid data (all NA or only one group present)
library(dplyr)

test_results <- combined_long %>%
  group_by(Skill_Format) %>%
  summarise(tab = list(table(group, Taught)), .groups = "drop") %>%
  rowwise() %>%
  mutate(
    is_valid = {
      dims <- dim(tab[[1]])
      !is.null(dims) && all(dims >= 2)
    }
  ) %>%
  filter(is_valid) %>%
  mutate(
    p_value = tryCatch(fisher.test(tab[[1]])$p.value, error = function(e) NA_real_),
    n_educator = if ("Educator" %in% rownames(tab[[1]])) sum(tab[[1]]["Educator", ]) else NA_integer_,
    n_employer = if ("Employer" %in% rownames(tab[[1]])) sum(tab[[1]]["Employer", ]) else NA_integer_,
    prop_educator = if (all(c("Educator", "1") %in% dimnames(tab[[1]]))) tab[[1]]["Educator", "1"] / sum(tab[[1]]["Educator", ]) else NA_real_,
    prop_employer = if (all(c("Employer", "1") %in% dimnames(tab[[1]]))) tab[[1]]["Employer", "1"] / sum(tab[[1]]["Employer", ]) else NA_real_
  ) %>%
  ungroup() %>%
  select(-tab, -is_valid) %>%
  arrange(p_value)


print(test_results)
```
ALSO: figure out what is causing the result to look like this
